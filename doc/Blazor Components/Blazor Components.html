<!DOCTYPE html>
<!-- saved from url=(0061)Blazor Components.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    

<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<!-- SEO Meta Tags -->
<meta name="description" content="Your description">
<meta name="author" content="Your name">

<!-- OG Meta Tags to improve the way the post looks when you share the page on Facebook, Twitter, LinkedIn -->
<meta property="og:site_name" content=""> <!-- website name -->
<meta property="og:site" content=""> <!-- website link -->
<meta property="og:title" content=""> <!-- title shown in the actual shared post -->
<meta property="og:description" content=""> <!-- description shown in the actual shared post -->
<meta property="og:image" content=""> <!-- image link, make sure it's jpg -->
<meta property="og:url" content=""> <!-- where do you want your post to link to -->
<meta name="twitter:card" content="summary_large_image"> <!-- to have large image post format in Twitter -->


<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">


<meta name="description" content="This article take a detailed look at the anatomy of a component and how it interacts with the rendering process.">
<meta name="author" content="Shaun Curtis">



<title>A Deep Dive into Blazor Components</title>


<!-- Custom fonts for this template-->
<link href="./Blazor Components_files/all.min.css" rel="stylesheet" type="text/css">
<link href="./Blazor Components_files/css" rel="stylesheet">

<!-- Custom styles for this template-->
<link href="./Blazor Components_files/sb-admin-2.css" rel="stylesheet" type="text/css">
<link href="./Blazor Components_files/site.css" rel="stylesheet" type="text/css">

<!-- Favicon  -->
<link rel="icon" href="https://shauncurtis.github.io/assets/images/favicon.png">


    <link rel="stylesheet" href="./Blazor Components_files/highlight.css">
    <link rel="stylesheet" href="./Blazor Components_files/article.css" type="text/css">
</head>
<body id="page-top">
    <!--topbar-->
    <div id="topbar">
        
<!-- Topbar -->
<nav class="navbar navbar-expand navbar-light topbar mb-4 static-top">
    
<ul class="navbar-nav">
<li class="nav-item">
<a class="nav-link " href="https://shauncurtis.github.io/index.html" role="button">
<span class="mr-2 d-none d-lg-inline text-gray-100">Index</span>
</a>
</li>
<li class="nav-item dropdown no-arrow mx-1">
<a class="nav-link dropdown-toggle" href="Blazor Components.html#" id="abf9566a-c79d-4da6-ab20-f7bfbaed0d74" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
<span class="mr-2 d-none d-lg-inline text-gray-100">Articles</span>
</a>
<div class=" dropdown-list dropdown-menu shadow animated--grow-in" aria-labelledby="abf9566a-c79d-4da6-ab20-f7bfbaed0d74">
<a class="dropdown-item" href="https://shauncurtis.github.io/articles/A-Flexible-App.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Creating a Dynamic Blazor App Component
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/articles/Async-Programming-in-DotNetCore.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Async Programming In Dotnetcore
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/articles/Blazor-AllinOne.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor All In One - Multi SPA Hosting
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/articles/Blazor-Async-Programming.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Async Programming
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/articles/Blazor-Brick-By-Brick.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Brick By Brick
</a>
<a class="dropdown-item" href="Blazor Components.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Components
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/articles/Blazor-CSS.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor CSS
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/articles/Blazor-DataList-Control.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Datalist Control
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/articles/Blazor-Form-Validation.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Form Validation
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/articles/Building-Blazor-List-Components.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building Blazor List Components and the Notification Pattern
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/articles/Building-Edit-Forms.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building Edit Forms
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/articles/EditFormState.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
The Blazor EditFormState Control
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/articles/Hydra.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Hydra
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/articles/Inline-Dialog.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
The Blazor Inline Dialog Control
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/articles/Modal-Dialog.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
A Blazor Modal Dialog
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/articles/Policy-Based-Authorization.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Policy Base Authorization in Blazor
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/articles/ValidationFormState.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
A Blazor Validation Control
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/articles/XML-XSD-Serialization.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
XML XSD Serialization
</a>
</div>
</li>
<li class="nav-item dropdown no-arrow mx-1">
<a class="nav-link dropdown-toggle" href="Blazor Components.html#" id="581de046-9823-4267-a59a-950a410ceb63" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
<span class="mr-2 d-none d-lg-inline text-gray-100">Blazor Database Apps</span>
</a>
<div class=" dropdown-list dropdown-menu shadow animated--grow-in" aria-labelledby="581de046-9823-4267-a59a-950a410ceb63">
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-1.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Database Application In Blazor Part 1
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-2.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Database Application In Blazor Part 2
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-3.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Database Application In Blazor Part 3
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-4.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Database Application In Blazor Part 4
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-5.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Database Application In Blazor Part 5
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-a-Database-Application-in-Blazor/Building-a-Database-Application-in-Blazor-Part-6.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Database Application In Blazor Part 6
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-a-Database-Application-in-Blazor/index.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building a Database Application in Blazor
</a>
</div>
</li>
<li class="nav-item dropdown no-arrow mx-1">
<a class="nav-link dropdown-toggle" href="Blazor Components.html#" id="00efdbfb-212c-4aea-a06b-46784e575335" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
<span class="mr-2 d-none d-lg-inline text-gray-100">Building Blazor Applications</span>
</a>
<div class=" dropdown-list dropdown-menu shadow animated--grow-in" aria-labelledby="00efdbfb-212c-4aea-a06b-46784e575335">
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-Blazor-Applications/Blazor-Async-UI-Events.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Async UI Events
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-Blazor-Applications/Blazor-Bootstrap-Toaster.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Bootstrap Toaster
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-Blazor-Applications/Blazor-Services.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Services
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-Blazor-Applications/Building-A-Blazor-AutoComplete-Control.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building A Blazor Autocomplete Control
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-Blazor-Applications/Building-Wrapper-Components.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building Wrapper Components
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-Blazor-Applications/DBContexts-In-Transient-Services.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Dbcontexts In Transient Services
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-Blazor-Applications/DynamicCss.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Dynamic Stylesheets
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-Blazor-Applications/For-ForEach-in-Blazor.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
For Foreach In Blazor
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-Blazor-Applications/Leaner-Meaner-Greener-Components.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Leaner Meaner Greener Components
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-Blazor-Applications/Notification-Service-Pattern.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Blazor Notification Service Pattern
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-Blazor-Applications/Rethinking-The-Repository-Pattern.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Rethinking The Repository Pattern
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-Blazor-Applications/The-Blazor-Component-Scope-Conumdrum.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
The Blazor Component Scope Conumdrum
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-Blazor-Applications/The-Blazor-WASM-Hosted-Project.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
The Blazor WASM Hosted Project
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-Blazor-Applications/Whats-Wrong-with-my-Component-Design.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Whats Wrong With My Component Design
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Building-Blazor-Applications/The-Blazor-Component">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Building Blazor Applications\The Blazor Component
</a>
</div>
</li>
<li class="nav-item dropdown no-arrow mx-1">
<a class="nav-link dropdown-toggle" href="Blazor Components.html#" id="64404f73-dfcf-44a1-b9d0-31b4ca346abe" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
<span class="mr-2 d-none d-lg-inline text-gray-100">Design</span>
</a>
<div class=" dropdown-list dropdown-menu shadow animated--grow-in" aria-labelledby="64404f73-dfcf-44a1-b9d0-31b4ca346abe">
<a class="dropdown-item" href="https://shauncurtis.github.io/Design/Clean-Design-In-Blazor.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Clean Design Principles in Blazor Applications
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Design/Clean-Design-Blazor-Template.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
A Blazor Clean Design Template
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Design/Clean-Design-Blazor-Template-Solution-Structure.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Solution Structure in the Clean Design Blazor Template
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Design/Clean-Design-Blazor-Template-DataServices.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Data Services in the Clean Design Blazor Template
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Design/Clean-Design-Blazor-Template-UI.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
The UI in the Clean Design Blazor Template
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Design/Clean-Design-Blazor-Template-Solution-Setup.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Solution Setup in the Clean Design Blazor Template
</a>
<a class="dropdown-item" href="https://shauncurtis.github.io/Design/Clean-Design-Blazor-Template-Testing.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Testing in the Clean Design Blazor Template
</a>
</div>
</li>
<li class="nav-item dropdown no-arrow mx-1">
<a class="nav-link dropdown-toggle" href="Blazor Components.html#" id="a80794a9-1b6a-43c6-a771-17033717b62c" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
<span class="mr-2 d-none d-lg-inline text-gray-100">Modern C#</span>
</a>
<div class=" dropdown-list dropdown-menu shadow animated--grow-in" aria-labelledby="a80794a9-1b6a-43c6-a771-17033717b62c">
<a class="dropdown-item" href="https://shauncurtis.github.io/Modern-Coding-Patterns/Nullable-And-VS-2022.html">
<i class="fas fa-file-alt fa-sm fa-fw mr-2 text-gray-600"></i>
Nullable And VS 2022
</a>
</div>
</li>
</ul>

    <div class="ms-5 me-5 ml-auto">
        <h1>Cold Elm Coders</h1>
    </div>
</nav>


    </div>
    <!--End topbar-->
    <!--Sidebar-->
    <div id="sidebar">
        
<div class="article-info p-2" published:="" 11-11-2020="">
<div>Published: 11-11-2020</div>
<div>Last Updated: 16-06-2021</div>
<div>Author: Shaun Curtis</div>
</div>

        
<h4 class="p-2">Table of Contents</h4>
<ul class="TOC">
<li class="TOC-item TOC-item-0">
<a class="TOC-link" href="Blazor Components.html#">Top</a>
<ul class="TOC TOC-0">
<li class="TOC-item TOC-item-1">
<ul class="TOC TOC-1">
<li class="TOC-item TOC-item-2">
<a class="TOC-link" href="Blazor Components.html#what-is-a-component">What is a Component?</a>
</li>
<li class="TOC-item TOC-item-2">
<a class="TOC-link" href="Blazor Components.html#the-renderer-and-the-render-tree">The Renderer and the Render Tree</a>
</li>
<li class="TOC-item TOC-item-2">
<a class="TOC-link" href="Blazor Components.html#the-client-application">The Client Application</a>
<ul class="TOC TOC-2">
<li class="TOC-item TOC-item-3">
<a class="TOC-link" href="Blazor Components.html#blazor-server">Blazor Server</a>
</li>
<li class="TOC-item TOC-item-3">
<a class="TOC-link" href="Blazor Components.html#blazor-web-assembly">Blazor Web Assembly</a>
</li>
</ul>
</li>
<li class="TOC-item TOC-item-2">
<a class="TOC-link" href="Blazor Components.html#components">Components</a>
<ul class="TOC TOC-2">
<li class="TOC-item TOC-item-3">
<a class="TOC-link" href="Blazor Components.html#the-helloworld-component">The HelloWorld Component</a>
</li>
<li class="TOC-item TOC-item-3">
<a class="TOC-link" href="Blazor Components.html#a-simple-icomponent-implementation">A Simple IComponent Implementation</a>
</li>
<li class="TOC-item TOC-item-3">
<a class="TOC-link" href="Blazor Components.html#routed-components">Routed Components</a>
</li>
</ul>
</li>
<li class="TOC-item TOC-item-2">
<a class="TOC-link" href="Blazor Components.html#componentbase">ComponentBase</a>
<ul class="TOC TOC-2">
<li class="TOC-item TOC-item-3">
<a class="TOC-link" href="Blazor Components.html#componentbase-lifecycle-and-events">ComponentBase Lifecycle and Events</a>
</li>
</ul>
</li>
<li class="TOC-item TOC-item-2">
<a class="TOC-link" href="Blazor Components.html#the-render-process">The Render Process</a>
<ul class="TOC TOC-2">
<li class="TOC-item TOC-item-3">
<a class="TOC-link" href="Blazor Components.html#component-content">Component Content</a>
</li>
</ul>
</li>
<li class="TOC-item TOC-item-2">
<a class="TOC-link" href="Blazor Components.html#component-events">Component Events</a>
</li>
<li class="TOC-item TOC-item-2">
<a class="TOC-link" href="Blazor Components.html#some-important-less-documented-information-and-lessons-learned">Some Important Less Documented Information and Lessons Learned</a>
<ul class="TOC TOC-2">
<li class="TOC-item TOC-item-3">
<a class="TOC-link" href="Blazor Components.html#keep-parameter-properties-simple">Keep Parameter Properties Simple</a>
</li>
<li class="TOC-item TOC-item-3">
<a class="TOC-link" href="Blazor Components.html#overriding-setparametersasync">Overriding SetParametersAsync</a>
</li>
<li class="TOC-item TOC-item-3">
<a class="TOC-link" href="Blazor Components.html#treat-parameters-as-immutable">Treat Parameters as Immutable</a>
</li>
<li class="TOC-item TOC-item-3">
<a class="TOC-link" href="Blazor Components.html#iterators">Iterators</a>
</li>
<li class="TOC-item TOC-item-3">
<a class="TOC-link" href="Blazor Components.html#component-numbering">Component Numbering</a>
</li>
</ul>
</li>
<li class="TOC-item TOC-item-2">
<a class="TOC-link" href="Blazor Components.html#building-components">Building Components</a>
</li>
<li class="TOC-item TOC-item-2">
<a class="TOC-link" href="Blazor Components.html#some-observations">Some Observations</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
    <!--End Sidebar-->
    <!-- Page Wrapper -->
    <div id="wrapper">
        <!-- Content Wrapper -->
        <div id="content-wrapper" class="d-flex flex-column">
            <!-- Main Content -->
            <div id="content">
                <!-- Topbar -->
                <div id="article">
                    <!-- Article -->
                    
<!-- Header -->
<header class="ex-header-article">
    <div class="container">
        <div class="row pt-3 pb-3 border-bottom">
            <div class="col">
                
<h1>A Deep Dive into Blazor Components</h1>
<div>This article take a detailed look at the anatomy of a component and how it interacts with the rendering process.</div>

            </div> <!-- end of col -->
        </div> <!-- end of row -->
    </div> <!-- end of container -->
</header> <!-- end of ex-header -->
<!-- end of header -->


                    
<!-- Article Container -->
<div class="ex-basic-1 pt-4">
    <div class="container">
        <div class="row">
            <div class="col-12">
                

        <h2 id="what-is-a-component">What is a Component?</h2>
<p>Microsoft defines:</p>
<p><em>A component is a self-contained portion of user interface (UI) with processing logic to enable dynamic behavior. Components can be nested, reused, shared among projects, and used in MVC and Razor Pages apps.</em></p>
<p><em>Components are implemented using a combination of C# and HTML markup in Razor component files with the .razor file extension.</em></p>
<p>What is does rather than what it is, and not all strictly true.</p>
<p>From a programming perspective, a component is a simply a class that implements the <code>IComponent</code> interface.  Nothing more.  It comes to life when it's attached to a <code>RenderTree</code>, the component tree used by a <code>Renderer</code> to build and update.  The <code>IComponent</code> interface proves the <code>Renderer</code>s  interface to communicate with and receive communication from a component.</p>
<p>Before we dive into components we need to look at the <code>Renderer</code> and <code>RenderTree</code>, and the application setting.</p>
<h2 id="the-renderer-and-the-render-tree">The Renderer and the Render Tree</h2>
<p>A detailed description of how the <code>Renderer</code> and <code>RenderTree</code> work is beyond the scope of this article, but you need a basic grasp of the concepts to understand the rendering process.</p>
<p>The <code>Renderer</code> and <code>RenderTree</code> reside in the Client Application in WASM and in the SignalR Hub Session in Server, i.e. one per connected Client Application.</p>
<p>The UI - defined by html code in the DOM [Document Object Model] - is represented in the application as a <code>RenderTree</code> and managed by a <code>Renderer</code>. Think of the <code>RenderTree</code> as a tree with one or more components attached to each branch. Each component is a C# class that implements the <code>IComponent</code> interface.  The <code>Renderer</code> has a <code>RenderQueue</code> which runs code to update the UI.  Components submit <code>RenderFragments</code> for the <code>Renderer</code> to run to update the <code>RenderTree</code> and the UI.  The <code>Renderer</code> uses a diffing process to detect changes in the DOM caused by <code>RenderTree</code> updates, and passes these to the client code to implement in the Browser DOM and update the displayed page.</p>
<p>The diagram below is a visual representation of the render tree for the out-of-the-box Blazor template.</p>
<p><img src="./Blazor Components_files/Root-Render-Tree.png" alt="Root Render Tree"></p>
<h2 id="the-client-application">The Client Application</h2>
<h3 id="blazor-server">Blazor Server</h3>
<p>Blazor Server defines the <code>&lt;app&gt;</code> component in the initial server/html page.  This looks like this:</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">app</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"typeof(App)"</span> <span class="hljs-attr">render-mode</span>=<span class="hljs-string">"ServerPrerendered"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">app</span>&gt;</span>
</div></code></pre>
<p><code>type</code> defines the route component class - in this case <code>App</code> and <code>render-mode</code> defines how the initial server-side render process runs.  You can read about that elsewhere.  The only important bit to understand is that if it pre-renders, the page is rendered twice on the initial load - once by the server to build a static version of the page, and then a second time by the browser client code to build the live version of the page.</p>
<p>The browser client code gets loaded by:</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"_framework/blazor.server.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</div></code></pre>
<p>Once <em>blazor.server.js</em> loads, the client application runs in the browser page and a SignalR connection estabished with the server.  To complete the initial load, the Client Application calls the Blazor Hub Session and requests a complete server render of the <code>App</code> component.  It then applies the resultant DOM changes to the Client Application DOM - this will principly be the event wiring.</p>
<p>The diagram below shows how a render request is passed to the displayed page.</p>
<p><img src="./Blazor Components_files/Server-Render.png" alt="Server Rendering"></p>
<h3 id="blazor-web-assembly">Blazor Web Assembly</h3>
<p>In Blazor WebAssembly the browser receives an Html page with a defined <code>div</code> placeholder where the root component should be loaded:</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    ....
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>The Client Application gets loaded by:</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"_framework/blazor.webassembly.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</div></code></pre>
<p>Once the WASM code is loaded, it runs <code>program</code>.</p>
<pre><code class="language-csharp"><div>builder.RootComponents.Add&lt;App&gt;(<span class="hljs-string">"#app"</span>);
</div></code></pre>
<p>The code tells the Renderer that the <code>App</code> class component is the root component for the <code>RenderTree</code> and to load it's DOM into the <code>app</code> element in the browser DOM.</p>
<p><img src="./Blazor Components_files/Web-Assembly-Render.png" alt="Server Rendering"></p>
<p>The key point to take from this is that although the process by which the root component is defined and loaded is different, there's no difference between in a WebAssembly and Server root component or any sub-component.  You can use the same component.</p>
<h4 id="apprazor">App.razor</h4>
<p><em>App.razor</em> is the "standard" root component.  It can be any <code>IComponent</code> defined class.</p>
<p><code>App</code> looks like this:</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">Router</span> <span class="hljs-attr">AppAssembly</span>=<span class="hljs-string">"@typeof(Program).Assembly"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Found</span> <span class="hljs-attr">Context</span>=<span class="hljs-string">"routeData"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">RouteView</span> <span class="hljs-attr">RouteData</span>=<span class="hljs-string">"@routeData"</span> <span class="hljs-attr">DefaultLayout</span>=<span class="hljs-string">"@typeof(MainLayout)"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Found</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">NotFound</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">LayoutView</span> <span class="hljs-attr">Layout</span>=<span class="hljs-string">"@typeof(MainLayout)"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Sorry, there's nothing at this address.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">LayoutView</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">NotFound</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span>
</div></code></pre>
<p>It's a Razor component defining one child component, <code>Router</code>.  <code>Router</code> has two <code>RenderFragments</code>, <code>Found</code> and <code>NotFound</code>.  If <code>Router</code> finds a route, and therefore an <code>IComponent</code> class, it renders the <code>RouteView</code> component and passes it the route class type along with the default <code>Layout</code> class.   If no route is found it renders a <code>LayoutView</code> and renders the defined content in it's <code>Body</code>.</p>
<p><code>RouteView</code> checks if the <code>RouteData</code> component has a specific layout class defined.  If so it uses it, otherwise it uses the default layout.  It renders the layout and passes it the type of the component to add to the <code>Body</code> RenderFragment.</p>
<h2 id="components">Components</h2>
<p>All components are normal DotNetCore classes that implement <code>IComponent</code>.</p>
<p>The <code>IComponent</code> interface definition is:</p>
<pre><code class="language-csharp"><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IComponent</span>
{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Attach</span>(<span class="hljs-params">RenderHandle renderHandle</span>)</span>;
    <span class="hljs-function">Task <span class="hljs-title">SetParametersAsync</span>(<span class="hljs-params">ParameterView parameters</span>)</span>;
}
</div></code></pre>
<p>My first reaction on seeing this was "What? Something missing here. Where's all those events and initialization methods?" Every article you read talks about components and  <code>OnInitialized</code>, ...  Don't let them confuse you.   These are part of <code>ComponentBase</code> the out-of-the-box Blazor implementation of <code>IComponent</code>.  <code>ComponentBase</code> does not define of a component.  You will see a much simpler implementation below.</p>
<p>Lets look at what is defined in more detail.  The Blazor Hub Session has a <code>Renderer</code> that runs the <code>RenderTree</code> for each root component.  Technically you can have more than one, but we'll ignore that for this discussion.  To quote the class documentation:</p>
<p><code>Renderer</code> provides mechanisms:</p>
<ol>
<li>For rendering hierarchies of <code>IComponent</code> instances;</li>
<li>Dispatching events to them;</li>
<li>Notifying when the user interface is being updated.</li>
</ol>
<p>A RenderHandle structure:</p>
<ol>
<li>Allows a component to interact with its renderer.</li>
</ol>
<p>Going back to the <code>IComponent</code> interface:</p>
<ol>
<li><code>Attach</code> is called when the <code>Renderer</code> attaches an <code>IComponent</code> object to the <code>RenderTree</code>.  It passes the component a <code>RenderHandle</code> struct.  The component uses this render handle to queue <code>RenderFragments</code> onto the <code>Renderer</code>'s <code>RenderQueue</code>.  We'll look at <code>RenderFragement</code> in more detail soon.</li>
<li><code>SetParametersAsync</code> is called by the <code>Renderer</code> on a component when it first attaches it to the <code>RenderTree</code> and whenever it deems one or more of the components <code>Parameters</code> has changed.</li>
</ol>
<p>Note that the <code>IComponent</code> has no concept of the <code>RenderTree</code>.  It gets triggered into action through a call to <code>SetParametersAsync</code> and it passes changes by calling a method on a <code>RenderHandle</code>.</p>
<h3 id="the-helloworld-component">The HelloWorld Component</h3>
<p>To demonstrate the <code>IComponent</code> interface We'll build a simple <code>HelloWorld</code> component.</p>
<p>Our simplest Hello World Razor component looks like this:</p>
<pre><code class="language-html"><div>@page "/helloworld"
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    Hello World
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>It's a Razor defined component.</p>
<p>We can refactor it to look like this:</p>
<pre><code class="language-csharp"><div>@page <span class="hljs-string">"/helloworld"</span>

@HelloWorld

@code {
    <span class="hljs-keyword">protected</span> RenderFragment HelloWorld =&gt; (RenderTreeBuilder builder) =&gt;
    {
        builder.OpenElement(<span class="hljs-number">0</span>, <span class="hljs-string">"div"</span>);
        builder.AddContent(<span class="hljs-number">1</span>, <span class="hljs-string">"Hello World 2"</span>);
        builder.CloseElement();
    };
}
</div></code></pre>
<p>This introduces the <code>RenderFragment</code>. To quote the official Microsoft documentation.</p>
<p><em>A RenderFragement represents a segment of UI content, implemented as a delegate that writes the content to a RenderTreeBuilder.</em></p>
<p>The <code>RenderTreeBuilder</code> is even more succinct:</p>
<p><em>Provides methods for building a collection of RenderTreeFrame entries.</em></p>
<p>So, a <code>RenderFragment</code> is a delegate - defined in <em>Microsoft.AspNetCore.Components</em> as follows:</p>
<pre><code class="language-csharp"><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RenderFragment</span>(<span class="hljs-params">RenderTreeBuilder builder</span>)</span>;
</div></code></pre>
<p>If you're new to delegates think of them as a pattern definition.  Any function that conforms to the pattern defined by <code>RenderFragment</code> delegate can passed as a <code>RenderFragment</code>.</p>
<p>The pattern dictates your method must:</p>
<ol>
<li>Have one, and only one, parameter of type <code>RenderTreeBuilder</code>.</li>
<li>Return a <code>void</code>.</li>
</ol>
<p>Looking back to the code above, we're defining a <code>RenderFragment</code> property and assigning an anonymous method to it that conforms to the <code>RenderFragment</code> pattern.  It takes a  <code>RenderTreeBuilder</code> and has no return so returns a void.  It uses the provided <code>RenderTreeBuilder</code> object to build the content: a simple hello world html div.  Each call to the builder adds what is called a <code>RenderTreeFrame</code>.  Note each frame is sequentially numbered.</p>
<p>It's important to understand two points:</p>
<ol>
<li>The component itself never "runs" the <code>RenderFragement</code>.  It is passed to the Renderer which Invokes it.</li>
<li>Even though the <code>Renderer</code> invokes the code, the code is run in the context of the component, and the state of the component when executing happens.</li>
</ol>
<h3 id="a-simple-icomponent-implementation">A Simple IComponent Implementation</h3>
<p>The <code>HelloWorld</code> component above inherits from <code>ComponentBase</code>.  Razor components that don't explicitly define inheritance inherit by default from <code>ComponentBase</code>.</p>
<p>We can now build our component as a simple C# class.</p>
<pre><code class="language-csharp"><div><span class="hljs-keyword">using</span> Microsoft.AspNetCore.Components;
<span class="hljs-keyword">using</span> Microsoft.AspNetCore.Components.Rendering;
<span class="hljs-keyword">using</span> Microsoft.AspNetCore.Components.Web;
<span class="hljs-keyword">using</span> System.Threading.Tasks;

<span class="hljs-keyword">namespace</span> <span class="hljs-title">Blazor.HelloWorld.Pages</span>
{
    [<span class="hljs-meta">RouteAttribute(<span class="hljs-meta-string">"/helloworld"</span>)</span>]
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RendererComponent</span> : <span class="hljs-title">IComponent</span>
    {
        <span class="hljs-keyword">private</span> RenderHandle _renderHandle;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Attach</span>(<span class="hljs-params">RenderHandle renderHandle</span>)</span>
        {
            _renderHandle = renderHandle;
        }

        <span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">SetParametersAsync</span>(<span class="hljs-params">ParameterView parameters</span>)</span>
        {
            parameters.SetParameterProperties(<span class="hljs-keyword">this</span>);
            <span class="hljs-keyword">this</span>.Render();
            <span class="hljs-keyword">return</span> Task.CompletedTask;
        }

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Render</span>(<span class="hljs-params"></span>)</span>
            =&gt; _renderHandle.Render(RenderComponent);

        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RenderComponent</span>(<span class="hljs-params">RenderTreeBuilder builder</span>)</span>
        {
            builder.OpenElement(<span class="hljs-number">0</span>, <span class="hljs-string">"div"</span>);
            builder.AddContent(<span class="hljs-number">1</span>, <span class="hljs-string">"Hello World 2"</span>);
            builder.CloseElement();
        }
    }
}
</div></code></pre>
<p>Points to note in the above code:</p>
<ol>
<li>The class uses the custom attribute <code>RouteAttribute</code> to define the route.</li>
<li>The class inherits from <code>IComponent</code>.</li>
<li>The class implements <code>Attach</code>.  The passed object <code>RenderHandle</code> is assigned to a local class field.</li>
<li>The class implements <code>SetParametersAsync</code> which is called when the component is first rendered, and whenever any <code>Parameters</code> are changed.  In our case never - we have no <code>Parameters</code> defined.  It calls the class method  <code>Render</code>.</li>
<li>The rest of the code is copied from the Razor component.</li>
<li>There's no <code>OnInitialized</code>, <code>OnAfterRender</code>, <code>StateHasChanged</code>,...  These are all  part of <code>ComponentBase</code>.</li>
</ol>
<p>The <code>Render</code> method calls <code>RenderHandle.Render</code> on the <code>RenderHandle</code> the component received when it was attached to the render tree.  It passes the <code>RenderComponent</code> method as a delegate.  Calling <code>Render</code> queues the passed delegate onto the Renderer's render queue.  This is where the code is actually executed.  Being a delegate it executes in the owning object's context.</p>
<p>The component is very simplistic, but it demonstrates the basics.</p>
<h3 id="routed-components">Routed Components</h3>
<p>Everything's a component, but not all components are equal.  <strong>Routed Components</strong> are a little special.</p>
<p>They contain <em>@page</em> routing directives and optionally a <em>@Layout</em> directive.</p>
<pre><code class="language-html"><div>@page "/WeatherForecast"
@page "/WeatherForecasts"
@layout MainLayout
</div></code></pre>
<p>You can define these directly on classes like this:</p>
<pre><code class="language-csharp"><div>[<span class="hljs-meta">LayoutAttribute(typeof(MainLayout))</span>]
[<span class="hljs-meta">RouteAttribute(<span class="hljs-meta-string">"/helloworld"</span>)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RendererComponent</span> : <span class="hljs-title">IComponent</span> {}
</div></code></pre>
<p>The <code>RouteAttribute</code> is used by the router to find Routes in the application.</p>
<p>Don't think of routed components as pages. It may seem obvious to do so, but don't.  Lots of web page properties don't apply to routed components.  You will:</p>
<ul>
<li>get confused when routed components don't behave like a page.</li>
<li>try and code the component logic as if it is a web page.</li>
</ul>
<h2 id="componentbase">ComponentBase</h2>
<p><code>ComponentBase</code> is the "standard" out-of-the-box Blazor implementation of <code>IComponent</code>.  All <em>.razor</em> files by default inherit from it.  While you may never step outside <code>ComponentBase</code> it's important to understand that it's just one implementation of the <code>IComponent</code> interface.  It doesn't define a component.  <code>OnInitialized</code> is not a component lifecycle method, it's a <code>ComponentBase</code> lifecycle method.</p>
<h3 id="componentbase-lifecycle-and-events">ComponentBase Lifecycle and Events</h3>
<p>There are articles galore regurgitating the same old basic lifecycle information.  I'm not going to repeat it.  Instead I'm going to concentrate on certain often misunderstood aspects of the lifecycle: there's more to the lifecycle that just the initial component load covered in most of the articles.</p>
<p>We need to consider five types of event:</p>
<ol>
<li>Instantiation of the class</li>
<li>Initialization of the component</li>
<li>Component parameter changes</li>
<li>Component events</li>
<li>Component disposal</li>
</ol>
<p>There are seven exposed Events/Methods and their async equivalents:</p>
<ol>
<li><code>SetParametersAsync</code></li>
<li><code>OnInitialized</code> and <code>OnInitializedAsync</code></li>
<li><code>OnParametersSet</code> and <code>OnParametersSetAsync</code></li>
<li><code>OnAfterRender</code> and <code>OnAfterRenderAsync</code></li>
<li><code>Dispose</code> - if <code>IDisposable</code> is implemented</li>
<li><code>StateHasChanged</code></li>
<li><code>new</code> - often forgotten.</li>
</ol>
<p>The standard class instantiation method builds the <code>RenderFragment</code> that <code>StateHasChanged</code> passes to the  <code>Renderer</code> to render the component.  It sets two private class variables to false and runs <code>BuildRenderTree</code>.</p>
<pre><code class="language-csharp"><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ComponentBase</span>(<span class="hljs-params"></span>)</span>
{
    _renderFragment = builder =&gt;
    {
        _hasPendingQueuedRender = <span class="hljs-literal">false</span>;
        _hasNeverRendered = <span class="hljs-literal">false</span>;
        BuildRenderTree(builder);
    };
}
</div></code></pre>
<p><code>SetParametersAsync</code> sets the properties for the submitted parameters. It only runs <code>RunInitAndSetParametersAsync</code> - and thus <code>OnInitialized</code> followed by <code>OnInitializedAsync</code> - on initialization. It always calls <code>CallOnParametersSetAsync</code>.  Note:</p>
<ol>
<li><code>CallOnParametersSetAsync</code> waits on <code>OnInitializedAsync</code> to complete before calling <code>CallOnParametersSetAsync</code>.</li>
<li><code>RunInitAndSetParametersAsync</code> calls <code>StateHasChanged</code> if <code>OnInitializedAsync</code> task yields before completion.</li>
</ol>
<pre><code class="language-csharp"><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Task <span class="hljs-title">SetParametersAsync</span>(<span class="hljs-params">ParameterView parameters</span>)</span>
{
    parameters.SetParameterProperties(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">if</span> (!_initialized)
    {
        _initialized = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> RunInitAndSetParametersAsync();
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> CallOnParametersSetAsync();
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">RunInitAndSetParametersAsync</span>(<span class="hljs-params"></span>)</span>
{
    OnInitialized();
    <span class="hljs-keyword">var</span> task = OnInitializedAsync();
    <span class="hljs-keyword">if</span> (task.Status != TaskStatus.RanToCompletion &amp;&amp; task.Status != TaskStatus.Canceled)
    {
        StateHasChanged();
        <span class="hljs-keyword">try</span> { <span class="hljs-keyword">await</span> task;}
        <span class="hljs-keyword">catch</span> { <span class="hljs-keyword">if</span> (!task.IsCanceled) <span class="hljs-keyword">throw</span>; }
    }
    <span class="hljs-keyword">await</span> CallOnParametersSetAsync();

</div></code></pre>
<p><code>CallOnParametersSetAsync</code> calls <code>OnParametersSet</code> followed by <code>OnParametersSetAsync</code>, and finally <code>StateHasChanged</code>.  If the <code>OnParametersSetAsync()</code> task yields <code>CallStateHasChangedOnAsyncCompletion</code> awaits the task and re-runs <code>StateHasChanged</code>.</p>
<pre><code class="language-csharp"><div><span class="hljs-function"><span class="hljs-keyword">private</span> Task <span class="hljs-title">CallOnParametersSetAsync</span>(<span class="hljs-params"></span>)</span>
{
    OnParametersSet();
    <span class="hljs-keyword">var</span> task = OnParametersSetAsync();
    <span class="hljs-keyword">var</span> shouldAwaitTask = task.Status != TaskStatus.RanToCompletion &amp;&amp;
        task.Status != TaskStatus.Canceled;

    StateHasChanged();

    <span class="hljs-keyword">return</span> shouldAwaitTask ?
        CallStateHasChangedOnAsyncCompletion(task) :
        Task.CompletedTask;
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">CallStateHasChangedOnAsyncCompletion</span>(<span class="hljs-params">Task task</span>)</span>
{
    <span class="hljs-keyword">try</span> { <span class="hljs-keyword">await</span> task; }
    <span class="hljs-keyword">catch</span> 
    {
        <span class="hljs-keyword">if</span> (task.IsCanceled) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">throw</span>;
    }
    StateHasChanged();
}
</div></code></pre>
<p>Lastly, lets look at <code>StateHasChanged</code>.  If a render is pending i.e. the renderer hasn't got round to running the queued render request, it closes - whatever changes have been made will be captured in the queued render.  If not, it sets the  <code>_hasPendingQueuedRender</code> class flag and calls the Render method on the <code>RenderHandle</code>.  This queues <code>_renderFragement</code> onto the <code>Renderer</code> <code>RenderQueue</code>.  When the queue runs <code>_renderFragment</code> - see above - it sets the two class flags to false and runs <code>BuildRenderTree</code>.</p>
<pre><code class="language-csharp"><div><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StateHasChanged</span>(<span class="hljs-params"></span>)</span>
{
    <span class="hljs-keyword">if</span> (_hasPendingQueuedRender) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (_hasNeverRendered || ShouldRender())
    {
        _hasPendingQueuedRender = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">try</span> { _renderHandle.Render(_renderFragment);}
        <span class="hljs-keyword">catch</span> {
            _hasPendingQueuedRender = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">throw</span>;
        }
    }
}
</div></code></pre>
<p>Some key points to note:</p>
<ol>
<li>
<p><code>OnInitialized</code> and <code>OnInitializedAsync</code> only get called during initialization.  <code>OnInitialized</code> is run first.  If, and only if, <code>OnInitializedAsync</code> yields back to the internal calling method <code>RunInitAndSetParametersAsync</code>, then <code>StateHasChanged</code> get called, providing the opportunity to provide "Loading" information to the user.  <code>OnInitializedAsync</code> completes before <code>OnParametersSet</code> and <code>OnParametersSetAsync</code> are called.</p>
</li>
<li>
<p><code>OnParametersSet</code> and <code>OnParametersSetAsync</code> get called whenever the parent component makes changes to the parameter set for the component or a captured cascaded parameter changes.  Any code that needs to respond to parameter changes need to live here. <code>OnParametersSet</code> is run first.  Note that if <code>OnParametersSetAsync</code> yields, <code>StateHasChanged</code> is run after the yield, providing the opportunity to provide "Loading" information to the user.</p>
</li>
<li>
<p><code>StateHasChanged</code> is called after the <code>OnParametersSet{async}</code> methods complete to render the component.</p>
</li>
<li>
<p><code>OnAfterRender</code> and <code>OnAfterRenderAsync</code> occur at the end of all four events.  <code>firstRender</code> is only true on component initialization.  Note that any changes made here to parameters won't get applied to display values until the component re-renders.</p>
</li>
<li>
<p><code>StateHasChanged</code> is called during the initialization process if the conditions stated above are met, after the <code>OnParametersSet</code> processes, and any event callback.  Don't call it explicitly during the render or parameter set process unless you need to.  If you do call it you are probably doing something wrong.</p>
</li>
</ol>
<h2 id="the-render-process">The Render Process</h2>
<p>Let's look in detail at how a simple page and component get rendered.</p>
<h4 id="simplecomponentrazor">SimpleComponent.razor</h4>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"h4 bg-success text-white p-2"</span>&gt;</span>Loaded<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<h4 id="simplepagerazor">SimplePage.razor</h4>
<pre><code class="language-csharp"><div>@page <span class="hljs-string">"/simple"</span>
&lt;h3&gt;SimplePage&lt;/h3&gt;
@if (loaded)
{
    &lt;SimpleComponent&gt;&lt;/SimpleComponent&gt;
}
<span class="hljs-keyword">else</span>
{
    &lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"h4 bg-danger text-white p-2"</span>&gt;Loading.....&lt;/div&gt;
}

@code {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> loaded;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">override</span> Task <span class="hljs-title">OnInitializedAsync</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">2000</span>);
        loaded = <span class="hljs-literal">true</span>;
    }
}
</div></code></pre>
<p>The follow diagram shows a simplified <code>RenderTree</code> representing a simple "/" route.</p>
<p><img src="./Blazor Components_files/Root-Render-Tree.png" alt="Root Render Tree"></p>
<p>Note the three nodes in <code>NavMenu</code> for the three <code>NavLink</code> controls.</p>
<p>On our page, the render tree looks like the diagram below on first render - we have a yielding <code>OnInitializedAsync</code> method, so <code>StateHasChanged</code> gets run in the initialization process.</p>
<p><img src="./Blazor Components_files/Simple-Page-Loading.png" alt="Simple Page Loading"></p>
<p>Once initialization completes, <code>StateHasChanged</code> is run a second time.  <code>Loaded</code> is now <code>true</code> and <code>SimpleComponent</code> is added to the component <code>RenderFragment</code>.  When the <code>Renderer</code> runs the <code>RenderFragment</code>, <code>SimpleComponent</code> is added to the render tree, instantiated and initialized.</p>
<p><img src="./Blazor Components_files/Simple-Page-Loaded.png" alt="Simple Page Loaded"></p>
<h3 id="component-content">Component Content</h3>
<p>Change <code>SimpleComponent</code> and <code>SimplePage</code> to:</p>
<h4 id="simplecomponentrazor-1">SimpleComponent.razor</h4>
<pre><code class="language-csharp"><div>&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"h4 bg-success text-white p-2"</span>&gt;@ChildContent&lt;/div&gt;

@code {
    [<span class="hljs-meta">Parameter</span>] <span class="hljs-keyword">public</span> RenderFragment ChildContent { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
}
</div></code></pre>
<h4 id="simplepagerazor-1">SimplePage.razor</h4>
<pre><code class="language-csharp"><div>@page <span class="hljs-string">"/simple"</span>
&lt;h3&gt;SimplePage&lt;/h3&gt;
@if (loaded)
{
    &lt;SimpleComponent&gt;
        &lt;button <span class="hljs-keyword">class</span>=<span class="hljs-string">"btn btn-primary"</span> @onclick=<span class="hljs-string">"ButtonClick"</span>&gt;Click Me&lt;/button&gt;
    &lt;/SimpleComponent&gt;
}
<span class="hljs-keyword">else</span>
{
    &lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"h4 bg-danger text-white p-2"</span>&gt;Loading.....&lt;/div&gt;
}

@code {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> loaded;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">override</span> Task <span class="hljs-title">OnInitializedAsync</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">2000</span>);
        loaded = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ButtonClick</span>(<span class="hljs-params">MouseEventArgs e</span>)</span>
    {
        <span class="hljs-keyword">var</span> x = <span class="hljs-literal">true</span>;
    }
}
</div></code></pre>
<p>There is now content in <code>SimpleComponent</code>. When the application is run that content gets executed in the context of the parent component.  How?</p>
<p>The answer is in <code>SimpleComponent</code>.   Remove the <code>[Parameter]</code> attribute from <code>SimpleComponent</code> and run the page.  It errors:</p>
<pre><code class="language-Text"><div>InvalidOperationException: Object of type 'xxx.SimpleComponent' has a property matching the name 'ChildContent', but it does not have [ParameterAttribute] or [CascadingParameterAttribute] applied.
</div></code></pre>
<p>If a component has "content" i.e. markup between the opening and closing tags, Blazor expects to find a <code>Parameter</code> named <code>ChildContent</code> in the component.  The content between the tags is pre-compiled into a <code>RenderFragment</code> and then added to the component.  The content of the <code>RenderFragment</code> is run in the context of the object that owns it - <code>SimplePage</code>.</p>
<p>The content can also be defined like this:</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">SimpleComponent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ChildContent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary"</span> @<span class="hljs-attr">onclick</span>=<span class="hljs-string">"ButtonClick"</span>&gt;</span>
            Click Me
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ChildContent</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">SimpleComponent</span>&gt;</span>
</div></code></pre>
<p>The page can also be re-written as below, where it now becomes more obvious who owns the <code>RenderFragment</code>.</p>
<pre><code class="language-csharp"><div>@page <span class="hljs-string">"/simple"</span>
&lt;h3&gt;SimplePage&lt;/h3&gt;
@if (loaded)
{
    &lt;SimpleComponent&gt;
        @_childContent
    &lt;/SimpleComponent&gt;
}
<span class="hljs-keyword">else</span>
{
    &lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"h4 bg-danger text-white p-2"</span>&gt;Loading.....&lt;/div&gt;
}

@code {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> loaded;

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">override</span> Task <span class="hljs-title">OnInitializedAsync</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">2000</span>);
        loaded = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ButtonClick</span>(<span class="hljs-params">MouseEventArgs e</span>)</span>
    {
        <span class="hljs-keyword">var</span> x = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">private</span> RenderFragment _childContent =&gt; (builder) =&gt;
    {
        builder.OpenElement(<span class="hljs-number">0</span>, <span class="hljs-string">"button"</span>);
        builder.AddAttribute(<span class="hljs-number">1</span>, <span class="hljs-string">"class"</span>, <span class="hljs-string">"btn btn-primary"</span>);
        builder.AddAttribute(<span class="hljs-number">2</span>, <span class="hljs-string">"onclick"</span>, EventCallback.Factory.Create&lt;MouseEventArgs&gt;(<span class="hljs-keyword">this</span>, ButtonClick));
        builder.AddContent(<span class="hljs-number">3</span>, <span class="hljs-string">"Click Me"</span>);
        builder.CloseElement();
    };
}
</div></code></pre>
<p>A component is not limited to a single <code>RenderFragment</code>.  A table component could look like this:</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">TableComponent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Header</span>&gt;</span>
        ...
    <span class="hljs-tag">&lt;/<span class="hljs-name">Header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Rows</span>&gt;</span>
        ...
    <span class="hljs-tag">&lt;/<span class="hljs-name">Rows</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Footer</span>&gt;</span>
        ...
    <span class="hljs-tag">&lt;/<span class="hljs-name">Footer</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">TableComponent</span>&gt;</span>
</div></code></pre>
<h2 id="component-events">Component Events</h2>
<p>The most important point to understand about Component events is they are <strong>NOT</strong> fire and forget.  All events are by default asynchronous and look like this:</p>
<pre><code class="language-csharp"><div><span class="hljs-keyword">var</span> task = InvokeAsync(HandlerMethod);
StateHasChanged();
<span class="hljs-keyword">if</span> (!task.IsCompleted)
{
    <span class="hljs-keyword">await</span> task;
    StateHasChanged();
}
</div></code></pre>
<p>So the following code won't execute as expected:</p>
<pre><code class="language-csharp"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">async</span> <span class="hljs-title">ButtonClick</span>(<span class="hljs-params">MouseEventArgs e</span>)</span> 
{
  <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">2000</span>);
  UpdateADisplayProperty();
}
</div></code></pre>
<p>The DisplayProperty doesn't display the current value until another <code>StateHasChanged</code> events occurs.  Why? ButtonClick doesn't return a <code>Task</code>, so there's nothing for the event handler to wait on.  It runs <code>StateHasChanged</code> before <code>UpdateADisplayProperty</code> completes.</p>
<p>This is a bandaid fix - it's bad pactice.</p>
<pre><code class="language-csharp"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">async</span> <span class="hljs-title">ButtonClick</span>(<span class="hljs-params">MouseEventArgs e</span>)</span> 
{
  <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">2000</span>);
  UpdateADisplayProperty();
  StateHasChanged();
}
</div></code></pre>
<p>The correct solution is:</p>
<pre><code class="language-csharp"><div><span class="hljs-function">Task <span class="hljs-keyword">async</span> <span class="hljs-title">ButtonClick</span>(<span class="hljs-params">MouseEventArgs e</span>)</span> 
{
  <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">2000</span>);
  UpdateADisplayProperty();
}
</div></code></pre>
<p>Now the event handle has a <code>Task</code> to await and doesn't execute <code>StateHasChanged</code> until <code>ButtonClick</code> completes.</p>
<h2 id="some-important-less-documented-information-and-lessons-learned">Some Important Less Documented Information and Lessons Learned</h2>
<h3 id="keep-parameter-properties-simple">Keep Parameter Properties Simple</h3>
<p>Your parameter declarations should look like this:</p>
<pre><code class="language-csharp"><div>[<span class="hljs-meta">Parameter</span>] MyClass myClass {<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;}
</div></code></pre>
<p><strong>DON'T</strong> add code to the getter or setter.  Why?  Any setter must be run as part of the render process and can have a significant impact on render speed and component state.</p>
<h3 id="overriding-setparametersasync">Overriding SetParametersAsync</h3>
<p>If you override <code>SetParametersAsync</code> your method should look like this:</p>
<pre><code class="language-csharp"><div>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Task <span class="hljs-title">SetParametersAsync</span>(<span class="hljs-params">ParameterView parameters</span>)</span>
    {
        <span class="hljs-comment">// always call first</span>
        parameters.SetParameterProperties(<span class="hljs-keyword">this</span>);
        <span class="hljs-comment">// Your Code</span>
        .....
        <span class="hljs-comment">// pass an empty ParameterView, not parameters</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">base</span>.SetParametersAsync(ParameterView.Empty);
    }
</div></code></pre>
<p>Set the parameters in the first line and call the base method passing <code>ParameterView.Empty</code>.  Don't try to pass <code>parameters</code> - you will get an error.</p>
<h3 id="treat-parameters-as-immutable">Treat Parameters as Immutable</h3>
<p>Never set Parameters in your code.  If you want to make or track changes do this:</p>
<pre><code class="language-csharp"><div>    [<span class="hljs-meta">Parameter</span>] <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> MyParameter { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> _MyParameter;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler MyParameterChanged;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">override</span> Task <span class="hljs-title">SetParametersAsync</span>(<span class="hljs-params">ParameterView parameters</span>)</span>
    {
        parameters.SetParameterProperties(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">if</span> (!_MyParameter.Equals(MyParameter))
        {
            _MyParameter = MyParameter;
            MyParameterChanged?.Invoke(_MyParameter, EventArgs.Empty);
        }
        <span class="hljs-keyword">await</span> <span class="hljs-keyword">base</span>.SetParametersAsync(ParameterView.Empty);
    }
</div></code></pre>
<h3 id="iterators">Iterators</h3>
<p>A common problem occurs when a <code>For</code> iterator is used to loop through a collection to build a <code>select</code> or a data table.  A typical example is shown below:</p>
<pre><code class="language-csharp"><div>@for (<span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>; counter &lt; <span class="hljs-keyword">this</span>.myList.Count; counter++)
{
    &lt;button <span class="hljs-keyword">class</span>=<span class="hljs-string">"btn btn-dark m-3"</span> @onclick=<span class="hljs-string">"() =&gt; ButtonClick(this.myList[counter])"</span>&gt;@this.myList[counter]&lt;/button&gt;
}
@for (<span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>; counter &lt; <span class="hljs-keyword">this</span>.myList.Count; counter++)
{
    &lt;button <span class="hljs-keyword">class</span>=<span class="hljs-string">"btn btn-dark m-3"</span> @onclick=<span class="hljs-string">"() =&gt; ButtonClick(counter)"</span>&gt;@this.myList[counter]&lt;/button&gt;
}
&lt;div&gt;Value = @this.<span class="hljs-keyword">value</span> &lt;/div&gt;

@code {
    <span class="hljs-keyword">private</span> List&lt;<span class="hljs-keyword">int</span>&gt; myList =&gt; <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">int</span>&gt; { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span> };
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span>;

    <span class="hljs-function"><span class="hljs-keyword">private</span> Task <span class="hljs-title">ButtonClick</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span></span>)</span>
    {
        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;
        <span class="hljs-keyword">return</span> Task.CompletedTask;
    }
}
</div></code></pre>
<p>If you click on a button in the first row, you will get a <em>Index was out of range</em> error.  Click on a button in the second row and value is always 10.  The reason is that the interator has completed before you click a button, at which time <code>counter</code> is 10.</p>
<p>To fix the problem, set a local variable within the loop as shown below.</p>
<pre><code class="language-csharp"><div>@for (<span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>; counter &lt; <span class="hljs-keyword">this</span>.myList.Count; counter++)
{
    <span class="hljs-keyword">var</span> item = <span class="hljs-keyword">this</span>.myList[counter];
    &lt;button <span class="hljs-keyword">class</span>=<span class="hljs-string">"btn btn-dark m-3"</span> @onclick=<span class="hljs-string">"() =&gt; ButtonClick(item)"</span>&gt;@item&lt;/button&gt;
}
@for (<span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>; counter &lt; <span class="hljs-keyword">this</span>.myList.Count; counter++)
{
    <span class="hljs-keyword">var</span> item = <span class="hljs-keyword">this</span>.myList[counter];
    <span class="hljs-keyword">var</span> thiscount = counter;
    &lt;button <span class="hljs-keyword">class</span>=<span class="hljs-string">"btn btn-info m-3"</span> @onclick=<span class="hljs-string">"() =&gt; ButtonClick(thiscount)"</span>&gt;@item&lt;/button&gt;
}
</div></code></pre>
<p>The best solution is to use <code>ForEach</code>.</p>
<pre><code class="language-csharp"><div>@foreach  (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.myList)
{
    &lt;button <span class="hljs-keyword">class</span>=<span class="hljs-string">"btn btn-primary m-3"</span> @onclick=<span class="hljs-string">"() =&gt; ButtonClick(item)"</span>&gt;@item&lt;/button&gt;
}
</div></code></pre>
<h3 id="component-numbering">Component Numbering</h3>
<p>It's seems logical to use iterators to automate the numbering of component elements.  DON'T.  The numbering system is used by the diffing engine to decide which bits of the DOM need updating and which bits don't.  Numbering must be consistent within a <code>RenderFragment</code>.  You can use <code>OpenRegion</code> and <code>CloseRegion</code> to define a region with it's own number space.  <a href="https://gist.github.com/SteveSandersonMS/ec232992c2446ab9a0059dd0fbc5d0c3">See this gist for a more detailed explanation</a>.</p>
<h2 id="building-components">Building Components</h2>
<p>Components can be defined in three ways:</p>
<ol>
<li>As a <em>.razor</em> file with an code inside an <em>@code</em> block.</li>
<li>As a <em>.razor</em> file and a code behind <em>.razor.cs</em> file.</li>
<li>As a pure <em>.cs</em> class file inheriting from <em>ComponentBase</em> or a <em>ComponentBase</em> inherited class, or implementing <em>IComponent</em>.</li>
</ol>
<h5 id="all-in-one-razor-file">All in One Razor File</h5>
<p>HelloWorld.razor</p>
<pre><code class="language-html"><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
@HelloWorld
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

@code {
[Parameter]
public string HelloWorld {get; set;} = "Hello?";
}
</div></code></pre>
<h5 id="code-behind">Code Behind</h5>
<p>HelloWorld.razor</p>
<pre><code class="language-html"><div>@inherits ComponentBase
@namespace CEC.Blazor.Server.Pages

<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
@HelloWorld
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>HelloWorld.razor.cs</p>
<pre><code class="language-csharp"><div><span class="hljs-keyword">namespace</span> <span class="hljs-title">CEC.Blazor.Server.Pages</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> : <span class="hljs-title">ComponentBase</span>
    {
        [<span class="hljs-meta">Parameter</span>]
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> HelloWorld {<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;} = <span class="hljs-string">"Hello?"</span>;
    }
}
</div></code></pre>
<h5 id="c-class">C# Class</h5>
<p>HelloWorld.cs</p>
<pre><code class="language-csharp"><div><span class="hljs-keyword">namespace</span> <span class="hljs-title">CEC.Blazor.Server.Pages</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> : <span class="hljs-title">ComponentBase</span>
    {
        [<span class="hljs-meta">Parameter</span>]
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> HelloWorld {<span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;} = <span class="hljs-string">"Hello?"</span>;

        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BuildRenderTree</span>(<span class="hljs-params">RenderTreeBuilder builder</span>)</span>
        {
            builder.OpenElement(<span class="hljs-number">0</span>, <span class="hljs-string">"div"</span>);
            builder.AddContent(<span class="hljs-number">1</span>, (MarkupString)<span class="hljs-keyword">this</span>._Content);
            builder.CloseElement();
        }
    }
}
</div></code></pre>
<h2 id="some-observations">Some Observations</h2>
<ol>
<li>
<p>There's a tendency to pile too much code into <code>OnInitialized</code> and <code>OnInitializedAsync</code> and then use events to drive <code>StateHasChanged</code> updates in the component tree.  Get the relevant code into the right places in the lifecycle and you won't need the events.</p>
</li>
<li>
<p>There's a temptation to start with the non-async versions (because they're easier to implement) and only use the async versions when you have to, when the opposite should be true.  Most web based activities are inherently async in nature.  I never use the non-async versions - I work on the principle that at some point I'm going to need to add async behaviour.</p>
</li>
<li>
<p><code>StateHasChanged</code> is called far to often, normally because code is in the wrong place in the component lifecycle, or the events have been coded incorrectly.  Ask yourself a challenging "Why?" when you type <code>StateHasChanged</code>.</p>
</li>
<li>
<p>Components are underused in the UI.  The same code/markup blocks are used repeatedly.  The same rules apply to code/markup blocks as to C# code.</p>
</li>
<li>
<p>Once you really, REALLY understand components, writing Blazor code becomes a totally "different" experience.</p>
</li>
</ol>

    

            </div>
        </div>
    </div>
</div>
<!-- end of Article Container -->


                </div>
                <!-- End of Main Content -->
            </div>
            <!-- Footer -->
            
<!-- Copyright -->
<footer class="sticky-footer bg-white">
    <div class="container my-auto">
        <div class="copyright text-center my-auto">
            
<span>Copyright © Cold Elm Coders - 2022</span>

        </div>
    </div>
</footer>
<!-- end of copyright -->


            <!-- End of Footer -->
        </div>
        <!-- End of Content Wrapper -->
        
<a class="scroll-to-top rounded" href="Blazor Components.html#page-top">
    <i class="fas fa-angle-up"></i>
</a>


    </div>
    <!-- End of Page Wrapper -->
    <!-- Scripts -->
    
<!-- Scripts -->
<!-- Bootstrap core JavaScript-->
<script src="./Blazor Components_files/jquery.min.js.download"></script>
<script src="./Blazor Components_files/bootstrap.bundle.min.js.download"></script>

<!-- Core plugin JavaScript-->
<script src="./Blazor Components_files/jquery.easing.min.js.download"></script>

<!-- Custom scripts for all pages-->
<script src="./Blazor Components_files/sb-admin-2.min.js.download"></script>




</body></html>